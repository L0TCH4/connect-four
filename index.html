<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>無限六角四目並べ オンライン</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a5f2a;
        }

        canvas {
            display: block
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
            display: none;
        }

        .active {
            display: block;
        }

        button {
            font-size: 18px;
            margin: 5px;
            padding: 10px 20px;
            cursor: pointer;
        }

        input {
            font-size: 18px;
            padding: 5px;
        }

        #status-msg {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 5px 15px;
            border-radius: 20px;
            pointer-events: none;
            font-size: 14px;
            display: none;
        }
    </style>
</head>

<body>
    <canvas id="cv"></canvas>
    <div id="status-msg"></div>

    <div id="ui-layer">
        <!-- タイトル画面 -->
        <div id="title-screen" class="ui-panel active">
            <h1>無限六角四目並べ</h1>
            <button onclick="startGame('local')">ローカル対戦 (2P)</button><br>
            <button onclick="startGame('cpu_w')">CPU対戦 (先手)</button><br>
            <button onclick="startGame('cpu_b')">CPU対戦 (後手)</button><br>
            <hr>
            <button onclick="showOnlineMenu()">オンライン対戦</button>
        </div>

        <!-- オンラインメニュー -->
        <div id="online-menu" class="ui-panel">
            <h2>オンライン対戦</h2>
            <button onclick="startHost()">ホストになる (部屋を作る)</button><br>
            <button onclick="startJoin()">ID入力して参加</button><br>
            <hr>
            <button onclick="startAutoMatch()">おまかせマッチング</button><br>
            <br>
            <div id="auto-match-status" style="display:none; color: yellow; font-size:smaller;">検索中...</div>
            <br>
            <input type="text" id="join-id-input" placeholder="相手のIDを入力" style="display:none">
            <button onclick="toggleManualInput()" id="manual-input-btn">ID指定モードへ</button><br>
            <br>
            <button onclick="backToTitle()">戻る</button>
        </div>

        <!-- ホスト待機画面 -->
        <div id="host-wait" class="ui-panel">
            <h2>対戦待ち...</h2>
            <p>以下のIDを相手に伝えてください</p>
            <h3 id="my-peer-id" style="user-select: text; background: #333; padding: 10px;">取得中...</h3>
            <p id="room-status-text"></p>
            <button onclick="cancelConnection()">キャンセル</button>
        </div>
    </div>

    <script>

        /* =====================
           Canvas
        ===================== */
        const cv = document.getElementById("cv");
        const ctx = cv.getContext("2d");
        function resize() {
            cv.width = innerWidth;
            cv.height = innerHeight;
            draw();
        }
        addEventListener("resize", resize);

        /* =====================
           State & Constants
        ===================== */
        const EMPTY = null;
        const BLACK = "B";
        const WHITE = "W";

        let board = [];
        let turn = BLACK;
        let gameOver = false;
        let vsCPU = false;
        let cpuColor = null;
        let originX = 0;
        let turnCountBlack = 1;
        let turnCountWhite = 1;

        let isOnline = false;
        let myColor = null; // Online mode: BLACK or WHITE
        let peer = null;
        let conn = null;

        let autoMatchIndex = 0;
        const AUTO_ID_PREFIX = "hex4-auto-room-";
        const AUTO_MAX_ROOMS = 20;
        let isAutoMatching = false;

        let view = { size: 50, ox: 0, oy: 0 };

        /* =====================
           UI Control
        ===================== */
        const uiTitle = document.getElementById("title-screen");
        const uiOnline = document.getElementById("online-menu");
        const uiHostWait = document.getElementById("host-wait");
        const statusMsg = document.getElementById("status-msg");
        const autoMatchStatus = document.getElementById("auto-match-status");
        const joinInput = document.getElementById("join-id-input");
        const manualBtn = document.getElementById("manual-input-btn");

        function showPanel(panel) {
            [uiTitle, uiOnline, uiHostWait].forEach(p => p.classList.remove("active"));
            if (panel) panel.classList.add("active");
        }

        function backToTitle() {
            cancelConnection();
            showPanel(uiTitle);
            initBoard();
            draw();
            statusMsg.style.display = "none";
            isAutoMatching = false;
            autoMatchStatus.style.display = "none";
        }

        function showOnlineMenu() {
            showPanel(uiOnline);
            joinInput.style.display = "none";
            document.querySelector("button[onclick='startJoin()']").style.display = "none";
            manualBtn.innerText = "ID指定モードへ";
        }

        function toggleManualInput() {
            if (joinInput.style.display === "none") {
                joinInput.style.display = "inline-block";
                document.querySelector("button[onclick='startJoin()']").style.display = "inline-block";
                manualBtn.style.display = "none";
            }
        }

        function showStatus(msg) {
            statusMsg.innerText = msg;
            statusMsg.style.display = "block";
        }

        /* =====================
           Game Start Logic
        ===================== */
        function initBoard() {
            originX = 0;
            board = [
                [EMPTY, BLACK],
                [WHITE, EMPTY]
            ];
            turnCountBlack = 1;
            turnCountWhite = 1;
            gameOver = false;
            turn = BLACK;
        }

        function startGame(mode) {
            initBoard();
            isOnline = false;
            vsCPU = false;
            cpuColor = null;

            if (mode === 'cpu_w') { vsCPU = true; cpuColor = WHITE; } // User is Black
            if (mode === 'cpu_b') { vsCPU = true; cpuColor = BLACK; } // User is White

            showPanel(null); // Hide all UI
            resize();

            if (vsCPU && turn === cpuColor) setTimeout(cpuMove, 300);
        }

        /* =====================
           PeerJS Logic
        ===================== */
        function initPeer(customId = null) {
            if (peer) peer.destroy();
            peer = customId ? new Peer(customId) : new Peer();

            peer.on('open', id => {
                console.log("My Peer ID: " + id);
                if (isAutoMatching && id.startsWith(AUTO_ID_PREFIX)) {
                    // I successfully became a Host of an auto-room
                    document.getElementById("my-peer-id").innerText = "ルーム " + id.replace(AUTO_ID_PREFIX, "");
                    document.getElementById("room-status-text").innerText = "対戦相手を待っています...";
                    showPanel(uiHostWait);
                } else {
                    document.getElementById("my-peer-id").innerText = id;
                }
            });

            peer.on('connection', c => {
                if (conn && conn.open) {
                    // Already connected, reject new connection
                    c.on('open', () => {
                        c.send({ type: 'FULL' });
                        setTimeout(() => c.close(), 500);
                    });
                    return;
                }
                conn = c;
                setupConnection(true); // true = I am Host
            });

            peer.on('error', err => {
                console.error(err);
                if (isAutoMatching) {
                    if (err.type === 'unavailable-id') {
                        // ID taken, so this room is occupied. Try to join it instead.
                        joinAutoRoom();
                    } else {
                        // Other error, retry next room
                        setTimeout(nextAutoMatch, 1000);
                    }
                    return;
                }
                alert("通信エラー: " + err.type);
                backToTitle();
            });
        }

        /* === Auto Match Logic === */
        function startAutoMatch() {
            isAutoMatching = true;
            autoMatchIndex = 0;
            autoMatchStatus.style.display = "block";
            autoMatchStatus.innerText = "検索開始...";
            nextAutoMatch();
        }

        function nextAutoMatch() {
            if (!isAutoMatching) return;
            if (autoMatchIndex >= AUTO_MAX_ROOMS) {
                autoMatchIndex = 0; // Loop or Random? Loop for now.
            }

            let roomId = AUTO_ID_PREFIX + autoMatchIndex;
            autoMatchStatus.innerText = `ルーム ${autoMatchIndex} を確認中...`;

            // Strategy: Try to BECOME the host of this room.
            // If successful -> Wait as Host.
            // If 'unavailable-id' -> Room exists, so try to JOIN it.
            initPeer(roomId);
        }

        function joinAutoRoom() {
            if (!isAutoMatching) return;
            let targetId = AUTO_ID_PREFIX + autoMatchIndex;

            // We need an anonymous ID to join
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', () => {
                conn = peer.connect(targetId);
                // Handling connection logic
                conn.on('open', () => {
                    // Success connecting! Wait for Role or Rejection
                    setupConnection(false);
                });
                conn.on('error', err => {
                    // Connection failed (maybe closed just now), try next
                    autoMatchIndex++;
                    nextAutoMatch();
                });
                conn.on('close', () => {
                    // Closed (maybe kicked/full), try next
                    if (isAutoMatching) {
                        autoMatchIndex++;
                        nextAutoMatch();
                    }
                });
            });
            peer.on('error', err => {
                // My anonymous peer failed? Retry next.
                autoMatchIndex++;
                nextAutoMatch();
            });
        }


        /* === Manual Logic === */

        function startHost() {
            isAutoMatching = false;
            initPeer();
            showPanel(uiHostWait);
            document.getElementById("room-status-text").innerText = "";
        }

        function startJoin() {
            isAutoMatching = false;
            const destId = document.getElementById("join-id-input").value;
            if (!destId) return alert("IDを入力してください");

            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', () => {
                conn = peer.connect(destId);
                conn.on('open', () => {
                    setupConnection(false);
                });
                conn.on('error', (err) => alert("接続エラー:" + err));
            });
        }

        function setupConnection(amIHost) {
            conn.on('data', data => {
                if (data.type === 'FULL') {
                    conn.close();
                    if (isAutoMatching) {
                        autoMatchIndex++;
                        nextAutoMatch();
                    } else {
                        alert("満員でした");
                        backToTitle();
                    }
                    return;
                }
                if (data.type === 'move') {
                    place(data.x, data.y, false);
                }
            });

            conn.on('close', () => {
                if (!gameOver && !isAutoMatching) alert("相手が切断しました");
                backToTitle();
            });

            // Connection Established!
            if (isAutoMatching) autoMatchStatus.style.display = "none";

            if (amIHost) {
                startGameOnline(BLACK);
            } else {
                startGameOnline(WHITE);
            }
        }

        function cancelConnection() {
            if (conn) conn.close();
            if (peer) peer.destroy();
            conn = null;
            peer = null;
            isAutoMatching = false;
        }

        function startGameOnline(color) {
            initBoard();
            isOnline = true;
            vsCPU = false;
            myColor = color;
            showPanel(null);
            resize();
            showStatus(myColor === BLACK ? "あなた: 黒 (先手)" : "あなた: 白 (後手)");

            if (vsCPU && turn === cpuColor) {
                setTimeout(cpuMove, 300);
            }
        }

        /* =====================
           Game Logic (Modified)
        ===================== */

        /* ... (Existing Logic Helpers: expandIfNeeded, canPlace, getNeighbors, isWin, etc.) ... */
        /* NOTE: reusing existing logic, but modified place() */

        const DIRS = [[0, -1], [0, 1], [-1, 0], [1, 0], [-1, 1], [1, -1]];

        function expandIfNeeded(x, y) {
            if (y === 0) { board.unshift(Array(board[0].length).fill(EMPTY)); y++; }
            if (y === board.length - 1) { board.push(Array(board[0].length).fill(EMPTY)); }
            if (x === 0) { board.forEach(r => r.unshift(EMPTY)); originX++; x++; }
            if (x === board[0].length - 1) { board.forEach(r => r.push(EMPTY)); }
            return [x, y];
        }

        function canPlace(x, y) {
            if (!board[y] || board[y][x] !== EMPTY) return false;
            let cnt = 0;
            const dirs = getNeighbors(x);
            for (let [dx, dy] of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (board[ny] && board[ny][nx]) cnt++;
            }
            return cnt >= 2;
        }

        function getNeighbors(x) {
            const odd = ((x - originX) & 1) === 1;
            if (!odd) return [[0, -1], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]];
            else return [[0, -1], [0, 1], [-1, 0], [-1, 1], [1, 0], [1, 1]];
        }

        /* Win Logic ... (Same as original) */
        function countLineHex(x, y, c, d1, d2) {
            let n = 1, cx = x, cy = y;
            while (true) { let [dx, dy] = d1(cx); cx += dx; cy += dy; if (board[cy] && board[cy][cx] === c) n++; else break; }
            cx = x; cy = y;
            while (true) { let [dx, dy] = d2(cx); cx += dx; cy += dy; if (board[cy] && board[cy][cx] === c) n++; else break; }
            return n;
        }
        function dirUpRight(x) { return ((x - originX) & 1) ? [1, 0] : [1, -1]; }
        function dirDownLeft(x) { return ((x - originX) & 1) ? [-1, 1] : [-1, 0]; }
        function dirUpLeft(x) { return ((x - originX) & 1) ? [-1, 0] : [-1, -1]; }
        function dirDownRight(x) { return ((x - originX) & 1) ? [1, 1] : [1, 0]; }

        function isWin(x, y, color) {
            if (countLineHex(x, y, color, x => [0, -1], x => [0, 1]) >= 4) return true;
            if (countLineHex(x, y, color, dirUpRight, dirDownLeft) >= 4) return true;
            if (countLineHex(x, y, color, dirUpLeft, dirDownRight) >= 4) return true;
            return false;
        }

        /* CPU & Helpers */
        function winningMoves(color) {
            let res = [];
            for (let y = 0; y < board.length; y++)
                for (let x = 0; x < board[0].length; x++) {
                    if (board[y][x] !== EMPTY) continue;
                    board[y][x] = color;
                    if (isWin(x, y, color)) res.push([x, y]);
                    board[y][x] = EMPTY;
                }
            return res.filter(([x, y]) => canPlace(x, y));
        }
        function isBadMove(x, y, color) {
            board[y][x] = color;
            if (winningMoves(color === BLACK ? WHITE : BLACK).length > 0) { board[y][x] = EMPTY; return true; }
            board[y][x] = EMPTY; return false;
        }
        function cpuMove() {
            const self = turn, enemy = (turn === BLACK ? WHITE : BLACK);
            let win = winningMoves(self);
            if (win.length) { place(win[0][0], win[0][1]); return; }
            let block = winningMoves(enemy);
            if (block.length) { place(block[0][0], block[0][1]); return; }
            let safe = [];
            for (let y = 0; y < board.length; y++)for (let x = 0; x < board[0].length; x++) {
                if (!canPlace(x, y)) continue;
                if (isBadMove(x, y, self)) continue;
                safe.push([x, y]);
            }
            for (let [x, y] of safe) {
                board[y][x] = self;
                if (winningMoves(self).length >= 2) { board[y][x] = EMPTY; place(x, y); return; }
                board[y][x] = EMPTY;
            }
            if (safe.length) { let p = safe[Math.floor(Math.random() * safe.length)]; place(p[0], p[1]); return; }

            // Random fallback
            let moves = [];
            for (let y = 0; y < board.length; y++)for (let x = 0; x < board[0].length; x++) if (canPlace(x, y)) moves.push([x, y]);
            if (moves.length) { let m = moves[Math.floor(Math.random() * moves.length)]; place(m[0], m[1]); }
        }


        function place(x, y, send = true) {
            // Send data BEFORE expansion changes coords?
            // Actually, if we send the indices, we should send them as they were CLICKED.
            // The 'place' function modifies the board. 
            // If we are Local, we click (x,y). We send (x,y). Logic runs, expands board.
            // If we are Remote, we receive (x,y). We run place(x,y). Logic runs, expands board EXACTLY SAME WAY.
            // Because both start from same board state, result is determinstic.

            if (isOnline && send && turn !== myColor) return; // Not my turn
            if (isOnline && send) {
                if (conn && conn.open) {
                    conn.send({ type: 'move', x: x, y: y });
                }
            }

            [x, y] = expandIfNeeded(x, y);
            board[y][x] = turn;

            if (turn == "B") turnCountBlack++;
            else turnCountWhite++;

            if (isWin(x, y, turn)) {
                gameOver = true;
                draw();
                if (isOnline) showStatus((turn === myColor ? "あなたの勝ち！" : "あなたの負け..."));
                return;
            }

            turn = (turn === BLACK ? WHITE : BLACK);

            if (isOnline) {
                showStatus(turn === myColor ? "あなたの番です" : "相手の番です");
            }

            draw();

            if (vsCPU && turn === cpuColor) {
                setTimeout(cpuMove, 300);
            }
        }

        /* =====================
           Input Event
        ===================== */
        function handleInput(mx, my) {
            if (gameOver) {
                // Click to return to title
                backToTitle();
                return;
            }

            // If online, can only move if it's my turn
            if (isOnline && turn !== myColor) return;
            // CPU turn block
            if (vsCPU && turn === cpuColor) return;

            for (let y = 0; y < board.length; y++) {
                for (let x = 0; x < board[0].length; x++) {
                    const px = view.ox + x * view.size;
                    const colParity = ((x - originX) & 1);
                    const py = view.oy + y * view.size + colParity * view.size * 0.5;

                    if (Math.hypot(mx - px, my - py) > view.size * 0.45) continue;
                    if (!canPlace(x, y)) return; // Valid move?

                    place(x, y, true); // True = Initiate move (send if online)
                    return;
                }
            }
        }

        cv.addEventListener("mousedown", e => {
            const r = cv.getBoundingClientRect();
            handleInput(e.clientX - r.left, e.clientY - r.top);
        });
        cv.addEventListener("touchstart", e => {
            e.preventDefault();
            const r = cv.getBoundingClientRect();
            const t = e.touches[0];
            handleInput(t.clientX - r.left, t.clientY - r.top);
        }, { passive: false });


        /* =====================
           Render
        ===================== */
        function draw() {
            ctx.clearRect(0, 0, cv.width, cv.height);

            // HUD
            ctx.fillStyle = "#040";
            ctx.font = "bold 20px sans-serif";
            ctx.textAlign = "left";

            let txt = (turn === BLACK ? "黒" : "白") + "の手番";
            if (isOnline) {
                txt += (turn === myColor ? " (あなた)" : " (相手)");
            }
            ctx.fillText(txt, 20, 30);
            ctx.fillText(`黒: ${turnCountBlack} / 白: ${turnCountWhite}`, 20, 60);

            // Board Calculation
            let minX = 1e9, maxX = -1e9, minY = 1e9, maxY = -1e9;
            board.forEach((r, y) => r.forEach((v, x) => {
                if (v) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); minY = Math.min(minY, y); maxY = Math.max(maxY, y); }
            }));
            let w = maxX - minX + 3, h = maxY - minY + 3;
            let size = Math.min(cv.width / (w + 1), cv.height / (h + 1), 60); // Max size cap

            let ox = cv.width / 2 - (minX + maxX) / 2 * size;
            let oy = cv.height / 2 - (minY + maxY) / 2 * size;

            view.size = size; view.ox = ox; view.oy = oy;

            ctx.lineWidth = 2;
            for (let y = 0; y < board.length; y++)
                for (let x = 0; x < board[0].length; x++) {
                    let px = ox + x * size;
                    let colParity = ((x - originX) & 1);
                    let py = oy + y * size + colParity * size * 0.5;

                    // Placeable hint
                    if (canPlace(x, y)) {
                        ctx.strokeStyle = "rgba(255,255,100,0.5)";
                        ctx.beginPath(); ctx.arc(px, py, size * 0.35, 0, Math.PI * 2); ctx.stroke();
                    }


                    // Stone
                    if (board[y][x]) {
                        ctx.fillStyle = board[y][x] === BLACK ? "black" : "white";
                        ctx.strokeStyle = "#333";
                        ctx.beginPath(); ctx.arc(px, py, size * 0.45, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    }
                }

            if (gameOver) {
                ctx.fillStyle = "rgba(255,0,0,0.8)";
                ctx.font = "bold 40px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText((turn === BLACK ? "黒" : "白") + "の勝利！", cv.width / 2, cv.height / 2);
                ctx.font = "20px sans-serif";
                ctx.fillText("画面タップでタイトルへ", cv.width / 2, cv.height / 2 + 50);
            }
        }

        // Init
        resize();
    </script>
</body>

</html>
